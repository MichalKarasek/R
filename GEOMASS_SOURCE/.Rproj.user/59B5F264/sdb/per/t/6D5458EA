{
    "collab_server" : "",
    "contents" : "Angle_intersection<-function(filepath, sigmaW, choice = FALSE, gon = TRUE){\n\n  Ro = 200/pi\n\n  values = read.table(file = filepath, header = FALSE, sep = \" \", dec = \".\")\n\n  dimension = dim(values)\n\n  if(dimension[1] == 5){\n\n    X_stanovisko_1 = values[1,1]\n    Y_stanovisko_1 = values[1,2]\n\n    ChybaX_stan_1 = values[4,1]\n    ChybaY_stan_1 = values[4,2]\n\n    X_stanovisko_2 = values[2,1]\n    Y_stanovisko_2 = values[2,2]\n\n    ChybaX_stan_2 = values[5,1]\n    ChybaY_stan_2 = values[5,2]\n\n      if(choice == TRUE){\n\n       Bod <- angle_intersection_calculation(values, gon)\n\n       X_urcovany_bod = Bod[1,1]\n       Y_urcovany_bod = Bod[1,2]\n\n     }else{\n\n       X_urcovany_bod = values[3,1]\n       Y_urcovany_bod = values[3,2]\n\n     }\n\n    D = matrix(c(-1, 0, 1, 0, 0, -1, 0, 1),nrow = 2)\n\n    Vzdalenost_urc_stan1 = sqrt((X_stanovisko_1 - X_urcovany_bod)^2 + (Y_stanovisko_1 - Y_urcovany_bod)^2)\n    Vzdalenost_urc_stan2 = sqrt((X_stanovisko_2 - X_urcovany_bod)^2 + (Y_stanovisko_2 - Y_urcovany_bod)^2)\n    Vzdalenosst_1_2 = sqrt((X_stanovisko_2 - X_stanovisko_1)^2 + (Y_stanovisko_2 - Y_stanovisko_1)^2)\n\n    # Matice vah\n\n    Vahy_mereni = diag(sigmaW, nrow = 4)^2\n    Vahy_podklad = diag(c(ChybaX_stan_1, ChybaY_stan_1, ChybaX_stan_2, ChybaY_stan_2), nrow = 4)^2\n\n    # Matice urcovane konfigurace\n\n    A1_1 = - (Y_urcovany_bod - Y_stanovisko_1) / (Vzdalenost_urc_stan1^2)\n    A1_2 = (X_urcovany_bod - X_stanovisko_1) / (Vzdalenost_urc_stan1^2)\n    A2_1 = (Y_urcovany_bod - Y_stanovisko_2) / (Vzdalenost_urc_stan2^2)\n    A2_2 = - (X_urcovany_bod - X_stanovisko_2) / (Vzdalenost_urc_stan2^2)\n\n    Matice_urcovane_konfigurace = Ro * matrix(c(A1_1, A2_1, A1_2, A2_2), nrow = 2)\n\n    # Matice dane konfigurace\n\n    B1_1 = (((Y_urcovany_bod - Y_stanovisko_1) / Vzdalenost_urc_stan1^2) - ((Y_stanovisko_2 - Y_stanovisko_1) / Vzdalenosst_1_2^2))\n    B1_2 = (((X_stanovisko_2 - X_stanovisko_1) / Vzdalenosst_1_2^2) - ((X_urcovany_bod - X_stanovisko_1) / Vzdalenost_urc_stan1^2))\n    B1_3 = (Y_stanovisko_2 - Y_stanovisko_1) / Vzdalenosst_1_2^2\n    B1_4 = - (X_stanovisko_2 - X_stanovisko_1) / Vzdalenosst_1_2^2\n    B2_1 = - (Y_stanovisko_1 - Y_stanovisko_2) / Vzdalenosst_1_2^2\n    B2_2 = (X_stanovisko_1 - X_stanovisko_2) / Vzdalenosst_1_2^2\n    B2_3 = (((Y_stanovisko_1 - Y_stanovisko_2) / Vzdalenosst_1_2^2) - ((Y_urcovany_bod - Y_stanovisko_2) / Vzdalenost_urc_stan2^2))\n    B2_4 = (((X_urcovany_bod - X_stanovisko_2) / Vzdalenost_urc_stan2^2) - ((X_stanovisko_1 - X_stanovisko_2) / Vzdalenosst_1_2^2))\n\n    Matice_dane_konfigurace = Ro * matrix(c(B1_1, B2_1, B1_2, B2_2, B1_3, B2_3, B1_4, B2_4), nrow = 2)\n\n    # Kovariancni matice mereni\n\n    K = solve(Matice_urcovane_konfigurace) %*% D\n\n    # Kovariancni matice podkladu\n\n    L = solve(Matice_urcovane_konfigurace) %*% Matice_dane_konfigurace\n\n    # Vliv mereni\n\n    Vliv_mer = K %*% Vahy_mereni %*% t(K)\n\n    #chyby\n    sigma_xm = sqrt(Vliv_mer[1,1])\n    sigma_ym = sqrt(Vliv_mer[2,2])\n    sigma_xym = sqrt(((sigma_xm^2 + sigma_ym^2)) / 2)\n\n    cm = sqrt((sigma_xm^2 - sigma_ym^2)^2 + 4 * Vliv_mer[1,2]^2)\n    am = sqrt((sigma_xm^2 + sigma_ym^2 + cm) / 2)\n    bm = sqrt((sigma_xm^2 + sigma_ym^2 - cm) / 2)\n    alfa2m = (atan2(2 * Vliv_mer[1,2], (sigma_xm^2 - sigma_ym^2))) * Ro\n    alfam = alfa2m / 2\n\n      if(alfa2m < 0){\n       alfam = (alfa2m + 400) / 2\n      }\n\n    # Vliv mereni a dane konfigurace\n\n    Vliv_celkovy = Vliv_mer + L %*% Vahy_podklad %*% t(L)\n\n    #chyby\n    sigma_x = sqrt(Vliv_celkovy[1,1])\n    sigma_y = sqrt(Vliv_celkovy[2,2])\n    sigma_xy = sqrt(((sigma_x^2 + sigma_y^2)) / 2)\n\n    c = sqrt((sigma_x^2 - sigma_y^2)^2 + 4*Vliv_celkovy[1,2]^2)\n    a = sqrt((sigma_x^2 + sigma_y^2 + c)/2)\n    b = sqrt((sigma_x^2 + sigma_y^2 - c)/2)\n    alfa2 = (atan2(2 * Vliv_celkovy[1,2], (sigma_x^2-sigma_y^2))) * Ro\n    alfa = alfa2 / 2\n\n      if(alfa2 < 0){\n        alfa = (alfa2 + 400) / 2\n      }\n\n    vector_X <- c(X_stanovisko_1, X_stanovisko_2, X_urcovany_bod)\n    vector_Y <- c(Y_stanovisko_1, Y_stanovisko_2, Y_urcovany_bod)\n    X_max <- vector_X[1]\n    X_min <- vector_X[1]\n    Y_max <- vector_Y[1]\n    Y_min <- vector_Y[1]\n\n    for(i in 1:length(vector_X)){\n\n      if(X_max < vector_X[i]){\n        X_max <- vector_X[i]\n      }\n\n      if(X_min > vector_X[i]){\n        X_min <- vector_X[i]\n      }\n\n      if(Y_max < vector_Y[i]){\n        Y_max <- vector_Y[i]\n      }\n\n      if(Y_min > vector_Y[i]){\n        Y_min <- vector_Y[i]\n      }\n    }\n\n    Elipsa_mereni <- Elipsa(am, bm, X_urcovany_bod, Y_urcovany_bod, alfam)\n    Elipsa_podkladu <- Elipsa(a, b, X_urcovany_bod, Y_urcovany_bod, alfa)\n\n    plot(Elipsa_mereni, type = \"l\", main = \"Error model - Angle intersection\", sub = \"Zoom 15 000x\", xlab = \"X [m]\", ylab = \"Y [m]\",\n         xlim = range(X_min-500, X_max+500), ylim = range(Y_min-500, Y_max+500), col = \"green\", lty = 1, asp = 1)\n    points(vector_X, vector_Y, pch=21, bg=\"red\")\n    lines(Elipsa_podkladu, type = \"l\", col = \"blue\", lty = 1)\n    legend(\"topright\", title = \"Error ellipsis\", c(\"Ellipse of measurements\", \"Ellipse of foundation\"), col = c(\"green\", \"blue\"), lty = c(1,1), bg = \"gray90\")\n\n    ellipsis <- data.frame(\n      Determined_point = c(\"Impact of measurement\",\"Impact of measurement + background\"),\n      Sigma_x_mm = round(c(sigma_xm, sigma_x), digits = 2),\n      Sigma_y_mm = round(c(sigma_ym, sigma_y), digits = 2),\n      Sigma_xy_mm = round(c(sigma_xym, sigma_xy), digits = 2),\n      Main_half_axis_a_mm = round(c(am, a), digits = 2),\n      Minor_half_axis_b_mm = round(c(bm, b), digits = 2),\n      Rotation_angle_gon = round(c(alfam, alfa), digits = 2),\n      stringsAsFactors = FALSE\n    )\n\n    write.csv(ellipsis, file = \"Output_Angle_intersection.csv\")\n    return(ellipsis)\n\n  }else if(dimension[1] == 3){\n\n    X_stanovisko_1 = values[1,1]\n    Y_stanovisko_1 = values[1,2]\n\n    X_stanovisko_2 = values[2,1]\n    Y_stanovisko_2 = values[2,2]\n\n      if(choice == TRUE){\n\n        Bod = angle_intersection_calculation(values, gon)\n\n        X_urcovany_bod = Bod[1,1]\n        Y_urcovany_bod = Bod[1,2]\n\n      }else{\n\n        X_urcovany_bod = values[3,1]\n        Y_urcovany_bod = values[3,2]\n\n      }\n\n    D = matrix(c(-1, 0, 1, 0, 0, -1, 0, 1),nrow = 2)\n\n    Vzdalenost_urc_stan1 = sqrt((X_stanovisko_1 - X_urcovany_bod)^2 + (Y_stanovisko_1 - Y_urcovany_bod)^2)\n    Vzdalenost_urc_stan2 = sqrt((X_stanovisko_2 - X_urcovany_bod)^2 + (Y_stanovisko_2 - Y_urcovany_bod)^2)\n    Vzdalenosst_1_2 = sqrt((X_stanovisko_2 - X_stanovisko_1)^2 + (Y_stanovisko_2 - Y_stanovisko_1)^2)\n\n    # Matice vah\n\n    Vahy_mereni = diag(sigmaW, nrow = 4)^2\n\n    # Matice urcovane konfigurace\n\n    A1_1 = - (Y_urcovany_bod - Y_stanovisko_1) / (Vzdalenost_urc_stan1^2)\n    A1_2 = (X_urcovany_bod - X_stanovisko_1) / (Vzdalenost_urc_stan1^2)\n    A2_1 = (Y_urcovany_bod - Y_stanovisko_2) / (Vzdalenost_urc_stan2^2)\n    A2_2 = - (X_urcovany_bod - X_stanovisko_2) / (Vzdalenost_urc_stan2^2)\n\n    Matice_urcovane_konfigurace = Ro * matrix(c(A1_1, A2_1, A1_2, A2_2), nrow = 2)\n\n    # Kovariancni matice mereni\n\n    K = solve(Matice_urcovane_konfigurace) %*% D\n\n    # Vliv mereni\n\n    Vliv_mer = K %*% Vahy_mereni %*% t(K)\n\n    #chyby\n    sigma_xm = sqrt(Vliv_mer[1,1])\n    sigma_ym = sqrt(Vliv_mer[2,2])\n    sigma_xym = sqrt(((sigma_xm^2+sigma_ym^2))/2)\n\n    cm = sqrt((sigma_xm^2 - sigma_ym^2)^2 + 4 * Vliv_mer[1,2]^2)\n    am = sqrt((sigma_xm^2 + sigma_ym^2 + cm) / 2)\n    bm = sqrt((sigma_xm^2 + sigma_ym^2 - cm) / 2)\n    alfa2m = (atan2(2 * Vliv_mer[1,2], (sigma_xm^2 - sigma_ym^2))) * Ro\n    alfam = alfa2m / 2\n\n      if(alfa2m < 0){\n        alfam = (alfa2m + 400) / 2\n      }\n\n      vector_X <- c(X_stanovisko_1, X_stanovisko_2, X_urcovany_bod)\n      vector_Y <- c(Y_stanovisko_1, Y_stanovisko_2, Y_urcovany_bod)\n      X_max <- vector_X[1]\n      X_min <- vector_X[1]\n      Y_max <- vector_Y[1]\n      Y_min <- vector_Y[1]\n\n      for(i in 1:length(vector_X)){\n\n        if(X_max < vector_X[i]){\n          X_max <- vector_X[i]\n        }\n\n        if(X_min > vector_X[i]){\n          X_min <- vector_X[i]\n        }\n\n        if(Y_max < vector_Y[i]){\n          Y_max <- vector_Y[i]\n        }\n\n        if(Y_min > vector_Y[i]){\n          Y_min <- vector_Y[i]\n        }\n      }\n\n      Elipsa_mereni <- Elipsa(am, bm, X_urcovany_bod, Y_urcovany_bod, alfam)\n\n      plot(Elipsa_mereni, type = \"l\", main = \"Elipsa chyb protinani z uhlu\", sub = \"Zvetseno 15 000\", xlab = \"X [m]\", ylab = \"Y [m]\",\n           xlim = range(X_min-500, X_max+500), ylim = range(Y_min-500, Y_max+500), col = \"green\", lty = 1, asp = 1)\n      points(vector_X, vector_Y, pch=21, bg=\"red\")\n      legend(\"topright\", title = \"Error ellipsis\", c(\"Ellipse of measurements\"), col = c(\"green\"), lty = c(1), bg = \"gray90\")\n\n      ellipsis <- data.frame(\n        Determined_point = c(\"Impact of measuremnt\"),\n        Sigma_x_mm = round(c(sigma_xm), digits = 2),\n        Sigma_y_mm = round(c(sigma_ym), digits = 2),\n        Sigma_xy_mm = round(c(sigma_xym), digits = 2),\n        Main_half_axis_a_mm = round(c(am), digits = 2),\n        Minor_half_axis_b_mm = round(c(bm), digits = 2),\n        Rotation_angle_gon = round(c(alfam), digits = 2),\n        stringsAsFactors = FALSE\n      )\n\n      write.csv(ellipsis, file = \"Output_Length_intersection.csv\")\n      return(ellipsis)\n\n  }else{\n\n    print(dimension[1])\n    stop(\"Invalid text file entry! Check help box for details.\")\n  }\n}\n\n\n",
    "created" : 1496833926370.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1632026035",
    "id" : "6D5458EA",
    "lastKnownWriteTime" : 1496834012,
    "last_content_update" : 1496834012020,
    "path" : "~/GEOMASS/R/Angle_intersection.R",
    "project_path" : "R/Angle_intersection.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}