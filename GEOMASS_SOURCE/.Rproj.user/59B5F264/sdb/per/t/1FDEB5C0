{
    "collab_server" : "",
    "contents" : "Length_intersection<-function(filepath, choice = FALSE){\n\n  options(digits=10)\n  ro = pi/200\n\n  values= read.table(file = filepath, header = FALSE, sep = \" \", dec = \".\")\n  dimension = dim(values)\n\n  if((dimension[1] == 4) && (values[4,1] != 0)){\n\n    y1 = values[1, 2]\n    x1 = values[1, 1]\n    y2 = values[2, 2]\n    x2 = values[2, 1]\n    ss = values[4, 1]\n    sd = values[4, 2]\n\n    if(choice == TRUE){\n\n      Bod <- length_intersection_calculation(values)\n\n      xp = Bod[1]\n      yp = Bod[2]\n\n    }else{\n\n      xp = values[3,1]\n      yp = values[3,2]\n    }\n\n    S1p = sqrt((x1 - xp) * (x1 - xp) + (y1 - yp) * (y1 - yp))\n    S2p = sqrt((x2 - xp) * (x2 - xp) + (y2 - yp) * (y2 - yp))\n\n    D=matrix( c(1, 0, 0, 1), nrow = 2, ncol = 2)\n\n    A1_1 = - (x1 - xp) / S1p\n    A1_2 = - (y1 - yp) / S1p\n    A1_3 = - (x2 - xp) / S2p\n    A1_4 = - (y2 - yp) / S2p\n\n    A1 = matrix( c(A1_1, A1_3, A1_2, A1_4), nrow = 2, ncol = 2)\n\n    A2_1 = (x1 - xp) / S1p\n    A2_2 = (y1 - yp) / S1p\n    A2_3 = 0\n    A2_4 = 0\n    A2_5 = 0\n    A2_6 = 0\n    A2_7 = (x2 - xp) / S2p\n    A2_8 = (y2 - yp) / S2p\n\n    A2 = matrix( c(A2_1, A2_5, A2_2, A2_6, A2_3, A2_7, A2_4, A2_8), nrow = 2, ncol = 4)\n\n    #kovariancni matice souradnic\n\n    K = solve(A1) %*% D\n    L = solve(A1) %*% A2\n\n    El_1 = c(sd^2, sd^2)\n    El = diag(El_1, 2, 2)\n\n    Ex_1 = c(ss^2, ss^2, ss^2, ss^2)\n    Ex = diag(Ex_1, 4, 4)\n\n    # kovarianci matice vlivu mereni\n\n    EXm = K %*% El %*% t(K)\n\n    #chyby\n\n    sigma_xm = sqrt(EXm[1, 1])\n    sigma_ym = sqrt(EXm[2, 2])\n    sigma_xym = sqrt(((sigma_xm^2 + sigma_ym^2)) / 2)\n\n    cm = sqrt((sigma_xm^2 - sigma_ym^2)^2 + 4 * EXm[1, 2]^2)\n    am = sqrt((sigma_xm^2 + sigma_ym^2 + cm) / 2)\n    bm = sqrt((sigma_xm^2 + sigma_ym^2 - cm) / 2)\n    alfa2m = (atan2(2 * EXm[1, 2], (sigma_xm^2 - sigma_ym^2))) * ro\n    alfam = alfa2m / 2\n    if(alfa2m < 0){(alfa2m + 400) / 2\n    }\n\n    #kovariancni matice souradnic\n\n    EX = K %*% El %*% t(K) + L %*% Ex %*% t(L)\n\n    #chyby\n\n    sigma_x = sqrt(EX[1, 1])\n    sigma_y = sqrt(EX[2, 2])\n    sigma_xy = sqrt(((sigma_x^2 + sigma_y^2)) / 2)\n\n    c = sqrt((sigma_x^2 - sigma_y^2)^2 + 4 * EX[1, 2]^2)\n    a = sqrt((sigma_x^2 + sigma_y^2 + c) / 2)\n    b = sqrt((sigma_x^2 + sigma_y^2 - c) / 2)\n    alfa2 = (atan2(2 * EX[1, 2], (sigma_x^2 - sigma_y^2))) * ro\n    alfa = alfa2 / 2\n    if(alfa2 < 0){\n      alfa = (alfa2 + 400) / 2\n    }\n\n    vector_X = c(x1, x2, xp)\n    vector_Y = c(y1, y2, yp)\n    X_max = vector_X[1]\n    X_min = vector_X[1]\n    Y_max = vector_Y[1]\n    Y_min = vector_Y[1]\n\n    for(i in 1:length(vector_X)){\n\n      if(X_max < vector_X[i]){\n        X_max = vector_X[i]\n      }\n\n      if(X_min > vector_X[i]){\n        X_min = vector_X[i]\n      }\n\n      if(Y_max < vector_Y[i]){\n        Y_max = vector_Y[i]\n      }\n\n      if(Y_min > vector_Y[i]){\n        Y_min = vector_Y[i]\n      }\n    }\n\n    Elipsa_mereni = Elipsa(am, bm, xp, yp, alfam)\n    Elipsa_podkladu = Elipsa(a, b, xp, yp, alfa)\n\n    plot(Elipsa_mereni, type = \"l\", main = \"Error ellipsis - Intersection from length\", sub = \"Zoom 15 000\", xlab = \"X [m]\", ylab = \"Y [m]\",\n         xlim = range(X_min-500, X_max+500), ylim = range(Y_min-500, Y_max+500), col = \"green\", lty = 1, asp = 1)\n    points(vector_X, vector_Y, pch=21, bg=\"red\")\n    lines(Elipsa_podkladu, type = \"l\", col = \"blue\", lty = 1)\n    legend(\"topright\", title = \"Error ellipsis\", c(\"Ellipse of measurements\", \"Ellipse of foundation\"), col = c(\"green\", \"blue\"), lty = c(1,1), bg = \"gray90\")\n\n    ellipsis <- data.frame(\n      Determined_point = c(\"Impact of measurement\",\"Impact of measurement + background\"),\n      Sigma_x_mm = round(c(sigma_xm, sigma_x), digits = 2),\n      Sigma_y_mm = round(c(sigma_ym, sigma_y), digits = 2),\n      Sigma_xy_mm = round(c(sigma_xym, sigma_xy), digits = 2),\n      Main_half_axis_a_mm = round(c(am, a), digits = 2),\n      Minor_half_axis_b_mm = round(c(bm, b), digits = 2),\n      Rotation_angle_gon = round(c(alfam, alfa), digits = 2),\n      stringsAsFactors = FALSE\n    )\n\n    write.csv(ellipsis, file = \"Output_Length_intersection.csv\")\n    return(ellipsis)\n\n  }else if((dimension[1] == 4) && (values[4, 1] == 0)){\n\n    y1 = values[1, 2]\n    x1 = values[1, 1]\n    y2 = values[2, 2]\n    x2 = values[2, 1]\n    sd = values[4, 2]\n\n    if(choice == TRUE){\n\n      Bod <- length_intersection_calculation(values)\n\n      xp = Bod[1]\n      yp = Bod[2]\n\n    }else{\n\n      xp = values[3,1]\n      yp = values[3,2]\n    }\n\n    S1p = sqrt((x1 - xp) * (x1 - xp) + (y1 - yp) * (y1 - yp))\n    S2p = sqrt((x2 - xp) * (x2 - xp) + (y2 - yp) * (y2 - yp))\n\n    D=matrix( c(1, 0, 0, 1), nrow = 2, ncol = 2)\n\n    A1_1 = - (x1 - xp) / S1p\n    A1_2 = - (y1 - yp) / S1p\n    A1_3 = - (x2 - xp) / S2p\n    A1_4 = - (y2 - yp) / S2p\n\n    A1 = matrix( c(A1_1, A1_3, A1_2, A1_4), nrow = 2, ncol = 2)\n\n    #kovariancni matice souradnic\n\n    K = solve(A1) %*% D\n\n    El_1 = c(sd^2, sd^2)\n    El = diag(El_1, 2, 2)\n\n    # kovarianci matice vlivu mereni\n\n    EXm = K %*% El %*% t(K)\n\n    #chyby\n\n    sigma_xm = sqrt(EXm[1, 1])\n    sigma_ym = sqrt(EXm[2, 2])\n    sigma_xym = sqrt(((sigma_xm^2 + sigma_ym^2)) / 2)\n\n    cm = sqrt((sigma_xm^2 - sigma_ym^2)^2 + 4 * EXm[1, 2]^2)\n    am = sqrt((sigma_xm^2 + sigma_ym^2 + cm) / 2)\n    bm = sqrt((sigma_xm^2 + sigma_ym^2 - cm) / 2)\n    alfa2m = (atan2(2 * EXm[1, 2], (sigma_xm^2 - sigma_ym^2))) * ro\n    alfam = alfa2m / 2\n    if(alfa2m < 0){(alfa2m + 400) / 2\n    }\n\n    vector_X = c(x1, x2, xp)\n    vector_Y = c(y1, y2, yp)\n    X_max = vector_X[1]\n    X_min = vector_X[1]\n    Y_max = vector_Y[1]\n    Y_min = vector_Y[1]\n\n    for(i in 1:length(vector_X)){\n\n      if(X_max < vector_X[i]){\n        X_max = vector_X[i]\n      }\n\n      if(X_min > vector_X[i]){\n        X_min = vector_X[i]\n      }\n\n      if(Y_max < vector_Y[i]){\n        Y_max = vector_Y[i]\n      }\n\n      if(Y_min > vector_Y[i]){\n        Y_min = vector_Y[i]\n      }\n    }\n\n    Elipsa_mereni = Elipsa(am, bm, xp, yp, alfam)\n\n    plot(Elipsa_mereni, type = \"l\", main = \"Error ellipsis - Intersection from lengths\", sub = \"Zoom 15 000\", xlab = \"X [m]\", ylab = \"Y [m]\",\n         xlim = range(X_min-500, X_max+500), ylim = range(Y_min-500, Y_max+500), col = \"green\", lty = 1, asp = 1)\n    points(vector_X, vector_Y, pch=21, bg=\"red\")\n    legend(\"topright\", title = \"Error ellipsis\", c(\"Ellipse of measurements\"), col = c(\"green\"), lty = c(1), bg = \"gray90\")\n\n    ellipsis <- data.frame(\n      Determined_point = c(\"Impact of measurement\"),\n      Sigma_x_mm = round(c(sigma_xm), digits = 2),\n      Sigma_y_mm = round(c(sigma_ym), digits = 2),\n      Sigma_xy_mm = round(c(sigma_xym), digits = 2),\n      Main_half_axis_a_mm = round(c(am), digits = 2),\n      Minor_half_axis_b_mm = round(c(bm), digits = 2),\n      Rotation_angle_gon = round(c(alfam), digits = 2),\n      stringsAsFactors = FALSE\n    )\n\n    write.csv(ellipsis, file = \"Output_Length_intersection.csv\")\n    return(ellipsis)\n\n  }else{\n\n    stop(\"Invalid text file entry! Check help box for details.\")\n  }\n}\n",
    "created" : 1497453269804.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "813760815",
    "id" : "1FDEB5C0",
    "lastKnownWriteTime" : 1497453372,
    "last_content_update" : 1497453372424,
    "path" : "~/GEOMASS/R/Length_intersection.R",
    "project_path" : "R/Length_intersection.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}